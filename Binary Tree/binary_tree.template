

#include "binary_tree.h"

template<typename T>
binary_tree::binary_tree(binary_tree *init_left, binary_tree *init_right, const T &entry) {
    left_field = init_left;
    right_field = init_right;
    data_field = entry;
}

template<class Process, class BTNode>
void inorder(Process f, BTNode *node_ptr)
// Library facilities used: cstdlib
{
    if (node_ptr != NULL) {
        inorder(f, node_ptr->left());
        f(node_ptr->data());
        inorder(f, node_ptr->right());
    }
}

template<class Process, class BTNode>
void postorder(Process f, BTNode *node_ptr)
// Library facilities used: cstdlib
{
    if (node_ptr != NULL) {
        postorder(f, node_ptr->left());
        postorder(f, node_ptr->right());
        f(node_ptr->data());
    }
}

template<class Process, class BTNode>
void preorder(Process f, BTNode *node_ptr)
// Library facilities used: cstdlib
{
    if (node_ptr != NULL) {
        f(node_ptr->data());
        preorder(f, node_ptr->left());
        preorder(f, node_ptr->right());
    }
}

template <class Item, class SizeType>
void print(binary_tree_node<Item>* node_ptr, SizeType depth)
// Library facilities used: iomanip, iostream, stdlib
{
    if (node_ptr != NULL)
    {
        print(node_ptr->right( ), depth+1);
        std::cout << std::setw(4*depth) << ""; // Indent 4*depth spaces.
        std::cout << node_ptr->data( ) << std::endl;
        print(node_ptr->left( ),  depth+1);
    }
}