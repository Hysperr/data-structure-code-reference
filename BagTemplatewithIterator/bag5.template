// FILE: bag5.template
// CLASS implemented: bag (see bag5.h for documentation)
// NOTE:
//   Since bag is a template class, this file is included in node2.h.
// INVARIANT for the bag class:
//   1. The items in the bag are stored on a linked list;
//   2. The head pointer of the list is stored in the member variable head_ptr;
//   3. The total number of items in the list is stored in the member variable
//       many_nodes.

#include <iostream>
#include <cassert>  // Provides assert
#include <cstdlib>  // Provides NULL, rand
#include "node2.h"  // Provides node
#include "bag5.h"

using namespace std;                        // CAN I DO THIS?????

template<class Item>
bag<Item>::bag()
// Library facilities used: cstdlib
{
    head_ptr = NULL;
    many_nodes = 0;
}

template<class Item>
bag<Item>::bag(const bag<Item> &source)
// Library facilities used: node2.h
{
    node<Item> *tail_ptr;  // Needed for argument of list_copy

    list_copy(source.head_ptr, head_ptr, tail_ptr);
    many_nodes = source.many_nodes;
}

template<class Item>
bag<Item>::~bag()
// Library facilities used: node2.h
{
    list_clear(head_ptr);
    many_nodes = 0;
}

template<class Item>
typename bag<Item>::size_type bag<Item>::count(const Item &target) const
// Library facilities used: cstdlib, node2.h
{
    size_type answer;
    const node<Item> *cursor;

    answer = 0;
    cursor = list_search(head_ptr, target);
    while (cursor != NULL) {
        // Each time that cursor is not NULL, we have another occurrence of
        // target, so we add one to answer, and move cursor to the next
        // occurrence of the target.
        ++answer;
        cursor = cursor->link();
        cursor = list_search(cursor, target);
    }
    return answer;
}

template<class Item>
typename bag<Item>::size_type bag<Item>::erase(const Item &target)
// Library facilities used: cstdlib, node2.h
{
    size_type answer = 0;
    node<Item> *target_ptr;

    target_ptr = list_search(head_ptr, target);
    while (target_ptr != NULL) {
        // Each time that target_ptr is not NULL, we have another occurrence
        // of target. We remove this target using the same technique that
        // was used in erase_one.
        ++answer;
        --many_nodes;
        target_ptr->set_data(head_ptr->data());
        target_ptr = target_ptr->link();
        target_ptr = list_search(target_ptr, target);
        list_head_remove(head_ptr);
    }
    return answer;
}

template<class Item>
bool bag<Item>::erase_one(const Item &target)
// Library facilities used: cstdlib, node2.h
{
    node<Item> *target_ptr;

    target_ptr = list_search(head_ptr, target);
    if (target_ptr == NULL)
        return false; // target isn't in the bag, so no work to do
    target_ptr->set_data(head_ptr->data());
    list_head_remove(head_ptr);
    --many_nodes;
    return true;
}

template<class Item>
Item bag<Item>::grab() const
// Library facilities used: cassert, cstdlib, node2.h
{
    size_type i;
    const node<Item> *cursor;

    assert(size() > 0);
    i = (std::rand() % size()) + 1;
    cursor = list_locate(head_ptr, i);
    return cursor->data();
}

template<class Item>
void bag<Item>::insert(const Item &entry)
// Library facilities used: node2.h
{
    list_head_insert(head_ptr, entry);
    ++many_nodes;
}

template<class Item>
void bag<Item>::operator+=(const bag<Item> &addend)
// Library facilities used: node2.h
{
    node<Item> *copy_head_ptr;
    node<Item> *copy_tail_ptr;

    if (addend.many_nodes > 0) {
        list_copy(addend.head_ptr, copy_head_ptr, copy_tail_ptr);
        copy_tail_ptr->set_link(head_ptr);
        head_ptr = copy_head_ptr;
        many_nodes += addend.many_nodes;
    }
}

template<class Item>
void bag<Item>::operator=(const bag<Item> &source)
// Library facilities used: node2.h
{
    node<Item> *tail_ptr; // Needed for argument to list_copy

    if (this == &source)
        return;

    list_clear(head_ptr);
    many_nodes = 0;

    list_copy(source.head_ptr, head_ptr, tail_ptr);
    many_nodes = source.many_nodes;
}

template<class Item>
bag<Item> operator+(const bag<Item> &b1, const bag<Item> &b2) {
    bag<Item> answer;

    answer += b1;
    answer += b2;
    return answer;
}

template<class Item>
void bag<Item>::printty_value_range(const Item &x, const Item &y) {
    if (count(x) == 0) {
        cout << "--nothing to see here--";
        return;
    }

    node<Item> *cursor = head_ptr;
    while (cursor != NULL) {
        if (cursor->data() == x) {
            while (cursor->data() != y && cursor != NULL) {
                cout << cursor->data() << " ";
                cursor = cursor->link();
            }
            cout << endl;
            return;
        }
        cursor = cursor->link();
    }


// Still working on it.


//	bool flag = true;
//	node<Item> *cur;
//	for (cur = head_ptr; cur != NULL; cur = cur->link()) {
//		if (cur->data() == x) {
//			flag = true;
//			while (flag && cur != NULL) {
//				cout << cur->data() << " ";
//				if (cur->link()->data() == y) {
//					flag = false;
//				}
//				cur = cur->link();
//			}
//
//		}
//		if (!flag) {
//			break;
//		}
//	}


//	bool flag = true;
//	node<Item> *cursor = head_ptr;
//	while (flag && cursor != NULL) {
//		if (cursor->data() == x) {
//			while (flag && cursor != NULL) {
//				cout << cursor->data() << " ";
//				if (cursor->link()->data() == y) {
//					flag = false;
//				}
//				cursor = cursor->link();
//			}
//		}
//	}



//	node<Item> *cur;
//	for (cur = head_ptr; cur != NULL; cur = cur->link()) {
//
//	}
//	node<Item> *p = NULL;
//	node<Item> *q;
//	node<Item> *dunno_ = NULL;
//	bool flagY = false;
//	node<Item> *cursor = head_ptr;
//	while (cursor != NULL) {
//		if (cursor->data() == x) {
//			p = cursor;
//			for (q = cursor; q != NULL; q = q->link()) {
//				if (q->data() == y) {
//					flagY = true;
//					dunno_ = q;
//					break;
//				}
//			}
//		}
//		cursor = cursor->link();
//	}
//	if (flagY) { // print from x to y
//		for (p; p != dunno_; p = p->link()) {
//			cout << p->data() << " ";
//		}
//		cout << endl;
//		return;
//	}
//	else {
//		for (p; p != NULL; p = p->link()) {
//			cout << p->data() << " ";
//		}
//		cout << endl;
//		return;
//	}

//	node<Item> *cursor;
//	for (cursor = head_ptr; cursor != NULL; cursor = cursor->link()) {
//		if (cursor->data() == x) {
//			while (cursor != NULL) {
//				cout << cursor->data() << " ";
//				cursor = cursor->link();
//			}
//			return;
//		}
//	}

}

template<class Item>
void bag<Item>::remove_repetitions() {
    node<Item> *p;
    for (p = head_ptr; p != NULL; p = p->link()) {
        node<Item> *q = p;
        while (q->link() != NULL) {
            if (q->link()->data() == p->data()) {
                list_remove(q);
            }
            q = q->link();
        }
    }
}
